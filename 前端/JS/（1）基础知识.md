## 类型转换

1. number有值，转换的时候为true
2. 数组为空时转换为0，长度为1时, 类型转换为那一个值`["a"] == "a"`
```
!!-1  // true

[] == 0  // true

["a"] == "a" // true
```

**转boolean**

在条件判断，除了`undefined`, `null`, `false`, `NaN`, `''`, `0`, `-0`,其他都为`true`， 包括所有对象

### 对象类型转基本类型

1. 对象转基本类型时，会调用valueOf 和toString,可以重写这两个方法, 默认`1 + {} === '1[object Object]'`。

2. 优先调用还是看倾向转化什么。`大部分都是会先调用valueOf`
```
let obj = {
  toString() {
    console.log('toString)
    return 'string'
  },
  valueOf() {
    console.log(''valueOf)
    return 'value'
  }
}

alert(obj) // string.目前发现alert是优先调用toString的

1 + obj // 1value
"a" + obj // avalue
```
1. 如果重写了toString方法，没有重写valueOf方法，则优先调用toString
```
var obj = {
  toString () {
    return 'string'
  }
}

console.log(1 + obj) // 1string
```

4. 如果调用valueOf 返回的不是原始类型的值，就会调用toString,如果toString也返回的不是原始类型值，就会报错
```
var obj = {
  toString () {
    console.log('toString')
    return {}
  },
  valueOf () {
    console.log('valueOf')
    return {}
  }
}

console.log(1 + obj)

// 报错。无法将一个对象转换为原始类型的值
Uncaught TypeError: Cannot convert object to primitive value
```

5. 如果有定义了`Symbol.toPrimitive`方法，则会有先调用（后面也不会去调用valueOf, toString了）,如果`Symbol.toPrimitive`方法返回的也不是原始类型，也同样报错

Primitive // 原始的
```
var obj = {
  toString () {
    console.log('toString')
    return {}
  },
  valueOf () {
    console.log('valueOf')
    return {}
  },
  [Symbol.toPrimitive] () {
    console.log('primitive')
    return 'primi'
  }
}

console.log(1 + obj) // 1primi
```

6. 特殊

```
var obj = {
  toString () {
    console.log('toString')
    return '1'
  },
  valueOf () {
    console.log('valueOf')
    return 2
  }
}

console.log(1 + obj)
console.log('1' + obj)
console.log(`1${obj}`)
// 依次输出
valueOf
3

valueOf
12

toString
11
```

'1' + obj没有返回11是因为`+`操作符倾向于转为number类型

```
let obj = {a: '1'}

1 + obj === 1 + obj.toString() // 结果为'1[object Object]'

obj.valueOf // 结果为{a: '1'}

let arr = [1, 2, 3]

1 + arr === 1 + obj.toString() // 结果为 11,2,3

arr.valueOf // 结果为[1, 2, 3]
```

### this

1. 多次bind,this永远是有第一次bind决定
```
let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // 结果为window
```

```
// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()
```

## 闭包

函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包

循环打印1, 2, 3, 4, 5
```
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```
**解决方法**
1. var 改用 let。 `优先使用`
2. 使用闭包，自执行函数，将i作为参数传入
3. 使用setTimeout第三个参数，会作为第一个参数（函数）的参数

## 深拷贝

**JSON.parse(JSON.stringify(object))**

局限性:

  1. 会忽略undefined
  2. 会忽略symbol
  3. 不能序列化函数(直接忽略)
  4. 不能解决循环引用的对象

JSON.stringify()

1. 第二个参数为函数，参考demo，为数组是，当key值存在数组中的，才返回，其他的过滤
2. 第三个参数是控制结果的缩进的，如果为数字，则缩进为2，更深层递加，最多10个空格，如果是字符串，则会缩进为该字符串（最多字符串的前10个字符）
```js
var data = {
  name:"niuzai",
  info:{
    age:18,
    sex:"male"
  }
};

// 第二个参数为函数时：

JSON.stringify(data, function(key, val){
  console.log("key is %s", key);
  console.log("val is %s", typeof(val));
  return val;
});

// 首先会打印个空Key, 和自身，再循环答应key, value
//key is
//val is object
//key is name
//val is string
//key is info
//val is object
//key is age
//val is number
//key is sex
//val is string
"{"name":"niuzai","info":{"age":18,"sex":"male"}}"

// 第二个参数为数字组时：
JSON.stringify(data, ["name", "info", "sex"]);

//age由于不在列表里，所以没被序列化
//"{"name":"niuzai","info":{"sex":"male"}}"
```
> 如果第二个参数，不返回val的话，后面也不会再进行遍历，

**MessageChannel**

`MessageChannel`也可以进行深拷贝，可以拷贝undefined 和循环应用
