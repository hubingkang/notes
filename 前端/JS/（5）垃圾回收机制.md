## 垃圾回收机制

### 内存泄漏

**内存泄漏（Memory Leak**）: 是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果

**GC(Garbage Collection)**: 垃圾回收，GC算法解决程序员手动管理内存

![](https://user-gold-cdn.xitu.io/2018/1/26/16132f0d10ccf76a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

闭包的内存泄漏： 函数内部的变量被函数外部所引用,函数结束不会释放变量内存。

```js
function hello() {
  let obj = {}
  return obj;
}

const result = hello()
```

### 常用的几种GC算法

**引用计数法**

记录有多少程序在引用自己

```js
var a = new Object(); // 此时'这个对象'的引用计数为1（a在引用）
var b = a; // ‘这个对象’的引用计数是2（a,b）
a = null; // reference_count = 1
b = null; // reference_count = 0 
// 下一步 GC来回收‘这个对象’了
```
优点：
  - 立即回收
  - 不用遍历所有的活动对象和非活动对象

缺点：
  - 计数器需要很大的位置
  - 无法解决循环引用的问题

**标记清除法**

标记阶段：

GC从全局作用域的变量，沿作用域逐层往里遍历（对，是深度遍历），当遍历到堆中对象时，说明该对象被引用着，则打上一个标记，继续递归遍历（因为肯定存在堆中对象引用另一个堆中对象），直到遍历到最后一个（最深的一层作用域）节点。

怎么标记不重要，关键在于采用什么策略

清除阶段：

遍历整个堆，回收没有打上标记的对象。


**复制算法**


---

调用 `window.CollectGarbage()`方法会立即执行垃圾收集,但是不会建议这么做